<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>MediaPipe Hands + micro:bit 左右上下</title>
<style>
  body { text-align: center; font-family: sans-serif; margin: 10px; }
  video, canvas { width: 45%; margin: 5px; border: 1px solid #333; vertical-align: top; }
  #status { color: blue; font-size: 18px; }
  #action { color: red; font-size: 28px; font-weight: bold; }
</style>
</head>

<body>
<h2>MediaPipe Hands → micro:bit（左右上下）</h2>

<div id="status">初始化...</div>
<div id="action">等待动作...</div>

<button id="connectBtn">连接 micro:bit（USB串口）</button>
<br>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>

<script type="module">
import {
  HandLandmarker,
  FilesetResolver,
  DrawingUtils
} from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

const statusEl = document.getElementById("status");
const actionEl = document.getElementById("action");
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const connectBtn = document.getElementById("connectBtn");

// USB 串口
let port = null;
let writer = null;

// 调参（可以之后做 slider）
let thresholdXY = 0.03;
let thresholdY  = 0.03;
let framesNeeded = 2;
let cooldown = 150;

// 平滑
let history = [];
const maxHistory = 5;

// 前一帧
let lastX = null;
let lastY = null;

let currentAction = null;
let actionCounter = 0;
let lastSent = 0;

// 中文映射
function toChinese(a) {
  return a==="LEFT" ? "左" :
         a==="RIGHT" ? "右" :
         a==="UP" ? "上" :
         a==="DOWN" ? "下" :
         "等待动作...";
}

// 串口发送
async function sendAction(a) {
  if (!writer) return;

  let msg = "0";
  if (a === "LEFT") msg = "L";
  if (a === "RIGHT") msg = "R";
  if (a === "UP") msg = "U";
  if (a === "DOWN") msg = "D";

  await writer.write(new TextEncoder().encode(msg + "\n"));
}

// 连接 USB micro:bit
connectBtn.addEventListener("click", async () => {
  try {
    port = await navigator.serial.requestPort();
    await port.open({ baudRate: 115200 });
    writer = port.writable.getWriter();
    connectBtn.disabled = true;
    statusEl.textContent = "micro:bit 已连接（USB）";
  } catch(e) {
    statusEl.textContent = "连接失败：" + e;
  }
});

// MediaPipe
let handLandmarker;

async function init() {
  statusEl.textContent = "加载模型...";
  const vision = await FilesetResolver.forVisionTasks(
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
  );

  handLandmarker = await HandLandmarker.createFromOptions(vision, {
    baseOptions: { modelAssetPath: "./hand_landmarker.task" },
    runningMode: "VIDEO",
    numHands: 1,
  });

  statusEl.textContent = "模型加载完成，启动摄像头...";
  startCamera();
}

function startCamera() {
  navigator.mediaDevices.getUserMedia({ video: true })
    .then(stream => {
      video.srcObject = stream;
      video.onloadedmetadata = () => {
        video.play();
        statusEl.textContent = "摄像头已启动";
        requestAnimationFrame(loop);
      };
    })
    .catch(err => {
      statusEl.textContent = "无法访问摄像头：" + err;
    });
}

async function loop(timestamp) {
  if (!handLandmarker) return;

  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;

  const results = await handLandmarker.detectForVideo(video, timestamp);

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  if (results.landmarks && results.landmarks.length > 0) {
    const lm = results.landmarks[0];
    new DrawingUtils(ctx).drawLandmarks(lm);

    const wrist = lm[0];

    history.push({ x: wrist.x, y: wrist.y });
    if (history.length > maxHistory) history.shift();

    const sum = history.reduce((a, p) => ({
      x: a.x + p.x, y: a.y + p.y
    }), { x: 0, y: 0 });

    const avgX = sum.x / history.length;
    const avgY = sum.y / history.length;

    let detected = null;

    if (lastX !== null && lastY !== null) {
      const dx = avgX - lastX;
      const dy = avgY - lastY;

      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > thresholdXY) detected = "RIGHT";
        else if (dx < -thresholdXY) detected = "LEFT";
      } else {
        if (dy < -thresholdY) detected = "UP";      // y 变小 → 上
        else if (dy > thresholdY) detected = "DOWN"; // y 变大 → 下
      }
    }

    lastX = avgX;
    lastY = avgY;

    // 连续帧检测 + cooldown
    if (detected === currentAction) {
      actionCounter++;
    } else {
      currentAction = detected;
      actionCounter = 1;
    }

    const now = performance.now();

    if (
      currentAction &&
      actionCounter >= framesNeeded &&
      now - lastSent > cooldown
    ) {
      actionEl.textContent = toChinese(currentAction);
      await sendAction(currentAction);
      lastSent = now;
    } else if (now - lastSent > 300) {
      actionEl.textContent = "等待动作...";
    }

  } else {
    actionEl.textContent = "没有检测到手";
    history = [];
    lastX = null;
    lastY = null;
  }

  requestAnimationFrame(loop);
}

window.addEventListener("load", init);
</script>

</body>
</html>

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>MediaPipe Hands + micro:bit 可调灵敏度</title>
<style>
body { text-align: center; font-family: sans-serif; margin: 10px; }
video, canvas { width: 45%; margin: 5px; border: 1px solid #333; vertical-align: top; }
#status { color: blue; font-size: 18px; }
#action { color: red; font-size: 24px; font-weight: bold; }
.slider-container { margin: 5px 0; }
</style>
</head>
<body>

<h2>MediaPipe Hands - USB micro:bit (可调灵敏度)</h2>
<div id="status">初始化...</div>
<div id="action">等待动作...</div>
<button id="connectBtn">连接 micro:bit</button>
<br>
<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>

<div class="slider-container">
    <label>动作灵敏度 (moveThreshold): <span id="moveVal">0.03</span></label><br>
    <input type="range" id="moveSlider" min="0.01" max="0.1" step="0.01" value="0.03">
</div>
<div class="slider-container">
    <label>连续帧数 (framesNeeded): <span id="frameVal">2</span></label><br>
    <input type="range" id="frameSlider" min="1" max="5" step="1" value="2">
</div>
<div class="slider-container">
    <label>冷却时间(ms): <span id="coolVal">150</span></label><br>
    <input type="range" id="coolSlider" min="50" max="500" step="10" value="150">
</div>

<script type="module">
import { HandLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

const statusEl = document.getElementById("status");
const actionEl = document.getElementById("action");
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

// USB micro:bit
let port;
let writer;

// 手势判定参数
let moveThreshold = parseFloat(document.getElementById("moveSlider").value);
let framesNeeded = parseInt(document.getElementById("frameSlider").value);
let cooldown = parseInt(document.getElementById("coolSlider").value);

document.getElementById("moveSlider").addEventListener("input", e=>{
    moveThreshold = parseFloat(e.target.value);
    document.getElementById("moveVal").textContent = moveThreshold.toFixed(2);
});
document.getElementById("frameSlider").addEventListener("input", e=>{
    framesNeeded = parseInt(e.target.value);
    document.getElementById("frameVal").textContent = framesNeeded;
});
document.getElementById("coolSlider").addEventListener("input", e=>{
    cooldown = parseInt(e.target.value);
    document.getElementById("coolVal").textContent = cooldown;
});

document.getElementById("connectBtn").addEventListener("click", async () => {
    try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        writer = port.writable.getWriter();
        statusEl.textContent = "micro:bit 已连接";
        connectBtn.disabled = true;
    } catch(e) {
        statusEl.textContent = "连接失败：" + e;
        console.error(e);
    }
});

// 手势识别
let handLandmarker;
let lastX = null;
let lastY = null;
let history = [];
const maxHistory = 5;
let actionCounter = 0;
let currentAction = null;
let lastSentTime = 0;

async function sendAction(action) {
    if (!writer) return;
    let sendMsg = action==="UP"?"1":action==="DOWN"?"2":action==="LEFT"?"3":action==="RIGHT"?"4":action==="FIST"?"5":"0";
    await writer.write(new TextEncoder().encode(sendMsg+"\n"));
}

async function init() {
    statusEl.textContent = "加载模型...";
    const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
    );
    handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: "./hand_landmarker.task" },
        runningMode: "VIDEO",
        numHands: 1,
    });
    statusEl.textContent = "模型加载完成，启动摄像头...";
    startCamera();
}

function startCamera() {
    navigator.mediaDevices.getUserMedia({ video:true })
        .then(stream=>{
            video.srcObject=stream;
            video.onloadedmetadata=()=>{ video.play(); statusEl.textContent="摄像头启动成功"; requestAnimationFrame(loop);}
        })
        .catch(err=>{statusEl.textContent="无法访问摄像头："+err; console.error(err);});
}

async function loop(timestamp){
    if(!handLandmarker) return;
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const results = await handLandmarker.detectForVideo(video, timestamp);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(video,0,0,canvas.width,canvas.height);

    if(results.landmarks && results.landmarks.length>0){
        const drawingUtils=new DrawingUtils(ctx);
        for(const l of results.landmarks){ drawingUtils.drawConnectors(l, HandLandmarker.HAND_CONNECTIONS); drawingUtils.drawLandmarks(l); }

        const wrist = results.landmarks[0][0];
        history.push({x:wrist.x,y:wrist.y});
        if(history.length>maxHistory) history.shift();
        const avgX = history.reduce((s,h)=>s+h.x,0)/history.length;
        const avgY = history.reduce((s,h)=>s+h.y,0)/history.length;

        let detectedAction="等待动作...";
        const lm = results.landmarks[0];
        function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}
        const thresholdFist=0.1;
        if(dist(lm[4],wrist)<thresholdFist && dist(lm[8],wrist)<thresholdFist &&
           dist(lm[12],wrist)<thresholdFist && dist(lm[16],wrist)<thresholdFist && dist(lm[20],wrist)<thresholdFist){
            detectedAction="FIST";
        } else if(lastX!==null && lastY!==null){
            const dx=avgX-lastX, dy=avgY-lastY;
            if(Math.abs(dx)>Math.abs(dy)){
                if(dx>moveThreshold) detectedAction="RIGHT";
                else if(dx<-moveThreshold) detectedAction="LEFT";
            } else {
                if(dy>moveThreshold) detectedAction="DOWN";
                else if(dy<-moveThreshold) detectedAction="UP";
            }
        }

        lastX=avgX; lastY=avgY;

        if(detectedAction===currentAction) actionCounter++;
        else {currentAction=detectedAction; actionCounter=1;}

        const now = performance.now();
        if(actionCounter>=framesNeeded && detectedAction!=="等待动作..." && now-lastSentTime>cooldown){
            actionEl.textContent=detectedAction;
            await sendAction(detectedAction);
            lastSentTime=now;
        } else {
            actionEl.textContent="等待动作...";
        }

    } else {
        actionEl.textContent="没有检测到手";
    }

    requestAnimationFrame(loop);
}

window.addEventListener("load", init);
</script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Hand Gesture + micro:bit BLE</title>
  <style>
    canvas {
      width: 100%;
      max-width: 400px;
      border: 2px solid #333;
      border-radius: 8px;
    }
    #connectBtn {
      padding: 10px 20px;
      font-size: 18px;
      margin: 10px 0;
      background: #4CAF50;
      color: white;
      border-radius: 8px;
      border: none;
    }
  </style>
</head>

<body>
  <h2>Hand Gesture + micro:bit BLE</h2>
  <button id="connectBtn">ğŸ”µ è¿æ¥åˆ° micro:bit</button>

  <canvas id="canvas"></canvas>

  <script type="module">
    import {
      HandLandmarker,
      FilesetResolver,
      DrawingUtils
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    // ----------------------
    // BLE å˜é‡
    // ----------------------
    let microbitDevice = null;
    let ledService = null;

    document.getElementById("connectBtn").onclick = async () => {
      try {
        microbitDevice = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: "BBC micro:bit" }],
          optionalServices: ["e95dd91d-251d-470a-a062-fa1922dfa9a8"]
        });

        const server = await microbitDevice.gatt.connect();
        ledService = await server.getPrimaryService(
          "e95dd91d-251d-470a-a062-fa1922dfa9a8"
        );

        alert("æˆåŠŸè¿æ¥ micro:bit âœ”");
      } catch (err) {
        console.error(err);
        alert("è¿æ¥å¤±è´¥ï¼Œè¯·é‡è¯•");
      }
    };

    async function sendGestureToMicrobit(command) {
      if (!ledService) return;
      try {
        const char = await ledService.getCharacteristic(
          "e95d7b77-251d-470a-a062-fa1922dfa9a8"
        );
        const data = new TextEncoder().encode(command);
        await char.writeValue(data);
        console.log("Sent:", command);
      } catch (err) {
        console.error("Write error:", err);
      }
    }

    // ----------------------
    // MediaPipe æ‰‹åŠ¿è¯†åˆ«
    // ----------------------
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    let handLandmarker;
    let videoStream;
    let videoElement;

    async function init() {
      // æ‘„åƒå¤´
      videoElement = document.createElement("video");
      videoElement.autoplay = true;
      videoElement.playsInline = true;

      try {
        videoStream = await navigator.mediaDevices.getUserMedia({ video: true });
        videoElement.srcObject = videoStream;
        await videoElement.play();
      } catch (err) {
        console.error("æ‘„åƒå¤´è®¿é—®å¤±è´¥:", err);
        alert("æ‘„åƒå¤´è®¿é—®å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™");
        return;
      }

      // MediaPipe
      const vision = await FilesetResolver.forVisionTasks("./wasm");
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: "./wasm/hand_landmarker.task" },
        runningMode: "VIDEO",
        numHands: 1
      });

      requestAnimationFrame(loop);
    }

    async function loop(timestamp) {
      canvas.width = videoElement.videoWidth;
      canvas.height = videoElement.videoHeight;

      // ç»˜åˆ¶æ‘„åƒå¤´ç”»é¢
      ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);

      // æ‰‹åŠ¿æ£€æµ‹
      const results = await handLandmarker.detectForVideo(videoElement, timestamp);

      if (results.landmarks) {
        const drawingUtils = new DrawingUtils(ctx);
        for (const lm of results.landmarks) {
          drawingUtils.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS);
          drawingUtils.drawLandmarks(lm);
        }

        const p0 = results.landmarks[0][0];

        if (p0.x < 0.3) sendGestureToMicrobit("LEFT");
        else if (p0.x > 0.7) sendGestureToMicrobit("RIGHT");
        else if (p0.y < 0.3) sendGestureToMicrobit("UP");
        else if (p0.y > 0.7) sendGestureToMicrobit("DOWN");
      }

      requestAnimationFrame(loop);
    }

    init();
  </script>
</body>
</html>

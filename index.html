<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>MediaPipe Hands + micro:bit 左/右/前/后</title>
<style>
  body { text-align: center; font-family: sans-serif; margin: 10px; }
  video, canvas {
    width: 45%; margin: 5px; border: 1px solid #333; vertical-align: top;
  }
  #status { color: blue; font-size: 18px; }
  #action { color: red; font-size: 24px; font-weight: bold; }
</style>
</head>
<body>

<h2>MediaPipe Hands - micro:bit 左/右/前/后</h2>
<div id="status">初始化...</div>
<div id="action">等待动作...</div>
<button id="connectBtn">连接 micro:bit</button>
<br>
<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>

<script type="module">
import {
  HandLandmarker,
  FilesetResolver,
  DrawingUtils
} from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

const statusEl = document.getElementById("status");
const actionEl = document.getElementById("action");
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const connectBtn = document.getElementById("connectBtn");

// 串口
let port;
let writer;

// 手势判定参数（你可以以后做成 slider）
let moveThresholdXY = 0.03;   // 左右灵敏度
let moveThresholdZ  = 0.03;   // 前后灵敏度
let framesNeeded    = 2;      // 需要连续多少帧
let cooldown        = 150;    // 冷却时间 ms

// 历史位置平滑
let history = [];
const maxHistory = 5;
let lastX = null;
let lastZ = null;

// 去抖
let currentAction = null;
let actionCounter = 0;
let lastSentTime = 0;

// 连接 micro:bit
connectBtn.addEventListener("click", async () => {
  try {
    if (!("serial" in navigator)) {
      statusEl.textContent = "当前浏览器不支持 Web Serial（建议用桌面版 Chrome）";
      return;
    }

    port = await navigator.serial.requestPort();
    await port.open({ baudRate: 115200 });
    writer = port.writable.getWriter();
    statusEl.textContent = "micro:bit 已连接";
    connectBtn.disabled = true;
  } catch (e) {
    statusEl.textContent = "连接失败：" + e;
    console.error(e);
  }
});

// 把英文动作转成中文文字
function actionToChinese(action) {
  switch (action) {
    case "LEFT":    return "左";
    case "RIGHT":   return "右";
    case "FORWARD": return "前";
    case "BACK":    return "后";
    default:        return "等待动作...";
  }
}

// 发送给 micro:bit
async function sendAction(action) {
  if (!writer) return;
  let msg = "0";
  switch (action) {
    case "LEFT":    msg = "L"; break;
    case "RIGHT":   msg = "R"; break;
    case "FORWARD": msg = "F"; break;
    case "BACK":    msg = "B"; break;
  }
  await writer.write(new TextEncoder().encode(msg + "\n"));
}

// MediaPipe 初始化
let handLandmarker;

async function init() {
  statusEl.textContent = "加载模型...";
  const vision = await FilesetResolver.forVisionTasks(
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
  );

  handLandmarker = await HandLandmarker.createFromOptions(vision, {
    baseOptions: {
      modelAssetPath: "./hand_landmarker.task"
    },
    runningMode: "VIDEO",
    numHands: 1,
  });

  statusEl.textContent = "模型加载完成，启动摄像头...";
  startCamera();
}

function startCamera() {
  navigator.mediaDevices.getUserMedia({ video: true })
    .then(stream => {
      video.srcObject = stream;
      video.onloadedmetadata = () => {
        video.play();
        statusEl.textContent = "摄像头启动成功";
        requestAnimationFrame(loop);
      };
    })
    .catch(err => {
      statusEl.textContent = "无法访问摄像头：" + err;
      console.error(err);
    });
}

async function loop(timestamp) {
  if (!handLandmarker) return;

  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;

  const results = await handLandmarker.detectForVideo(video, timestamp);

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  if (results.landmarks && results.landmarks.length > 0) {
    const lmList = results.landmarks[0]; // 只看一只手
    const drawingUtils = new DrawingUtils(ctx);
    drawingUtils.drawConnectors(lmList, HandLandmarker.HAND_CONNECTIONS);
    drawingUtils.drawLandmarks(lmList);

    // 手腕：index 0
    const wrist = lmList[0];
    history.push({ x: wrist.x, y: wrist.y, z: wrist.z });
    if (history.length > maxHistory) history.shift();

    const avg = history.reduce(
      (acc, p) => {
        acc.x += p.x; acc.y += p.y; acc.z += p.z;
        return acc;
      },
      { x: 0, y: 0, z: 0 }
    );

    const n = history.length;
    const avgX = avg.x / n;
    const avgZ = avg.z / n;

    let detectedAction = null;

    if (lastX !== null && lastZ !== null) {
      const dx = avgX - lastX; // 左右
      const dz = avgZ - lastZ; // 前后（z 越小越靠近摄像头）

      // 比较左右和前后哪个更明显
      if (Math.abs(dx) > Math.abs(dz)) {
        if (dx > moveThresholdXY) {
          detectedAction = "RIGHT";
        } else if (dx < -moveThresholdXY) {
          detectedAction = "LEFT";
        }
      } else {
        if (dz < -moveThresholdZ) {
          detectedAction = "FORWARD"; // 手向前伸
        } else if (dz > moveThresholdZ) {
          detectedAction = "BACK";    // 手往后收
        }
      }
    }

    lastX = avgX;
    lastZ = avgZ;

    // 去抖：需要连续 framesNeeded 帧都是同一个动作
    if (detectedAction && detectedAction === currentAction) {
      actionCounter++;
    } else if (detectedAction) {
      currentAction = detectedAction;
      actionCounter = 1;
    } else {
      // 没有明显动作
      currentAction = null;
      actionCounter = 0;
    }

    const now = performance.now();

    if (
      currentAction &&
      actionCounter >= framesNeeded &&
      now - lastSentTime > cooldown
    ) {
      // 触发动作
      actionEl.textContent = actionToChinese(currentAction);
      await sendAction(currentAction);
      lastSentTime = now;
    } else if (!currentAction && now - lastSentTime > 300) {
      actionEl.textContent = "等待动作...";
    }

  } else {
    actionEl.textContent = "没有检测到手";
    history = [];
    lastX = null;
    lastZ = null;
  }

  requestAnimationFrame(loop);
}

window.addEventListener("load", init);
</script>

</body>
</html>

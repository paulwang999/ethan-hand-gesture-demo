<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>MediaPipe Hands + micro:bit（食指控制 左右上下）</title>
<style>
  body { text-align: center; font-family: sans-serif; margin: 10px; }
  video, canvas { width: 45%; margin: 5px; border: 1px solid #333; vertical-align: top; }
  #status { color: blue; font-size: 18px; }
  #action { color: red; font-size: 28px; font-weight: bold; }
  .slider-container { margin: 5px 0; }
</style>
</head>

<body>

<h2>MediaPipe Hands → micro:bit（食指控制 左/右/上/下）</h2>

<div id="status">初始化...</div>
<div id="action">等待动作...</div>

<button id="connectBtn">连接 micro:bit</button>
<br>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>

<!-- 灵敏度设置（可调） -->
<div class="slider-container">
    <label>手指方向强度阈值 (dirThreshold): <span id="moveVal">0.05</span></label><br>
    <input type="range" id="moveSlider" min="0.02" max="0.15" step="0.01" value="0.05">
</div>
<div class="slider-container">
    <label>连续帧数 (framesNeeded): <span id="frameVal">2</span></label><br>
    <input type="range" id="frameSlider" min="1" max="5" step="1" value="2">
</div>
<div class="slider-container">
    <label>冷却时间(ms): <span id="coolVal">150</span></label><br>
    <input type="range" id="coolSlider" min="50" max="500" step="10" value="150">
</div>

<!-- ======================= -->
<!-- ⚠️ 脚本一定放在 canvas 后面 -->
<!-- ======================= -->
<script type="module">
import { HandLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

const statusEl  = document.getElementById("status");
const actionEl  = document.getElementById("action");
const video     = document.getElementById("video");
const canvas    = document.getElementById("canvas");
const ctx       = canvas.getContext("2d");
const connectBtn = document.getElementById("connectBtn");

// USB serial
let port;
let writer;

// 参数
let dirThreshold = parseFloat(document.getElementById("moveSlider").value);
let framesNeeded = parseInt(document.getElementById("frameSlider").value);
let cooldown     = parseInt(document.getElementById("coolSlider").value);

// slider 更新
document.getElementById("moveSlider").addEventListener("input", e=>{
    dirThreshold = parseFloat(e.target.value);
    document.getElementById("moveVal").textContent = dirThreshold.toFixed(2);
});
document.getElementById("frameSlider").addEventListener("input", e=>{
    framesNeeded = parseInt(e.target.value);
    document.getElementById("frameVal").textContent = framesNeeded;
});
document.getElementById("coolSlider").addEventListener("input", e=>{
    cooldown = parseInt(e.target.value);
    document.getElementById("coolVal").textContent = cooldown;
});

// 连接 micro:bit（USB）
connectBtn.addEventListener("click", async () => {
    try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        writer = port.writable.getWriter();
        connectBtn.disabled = true;
        statusEl.textContent = "micro:bit 已连接（USB）";
    } catch (e) {
        statusEl.textContent = "连接失败：" + e;
        console.error(e);
    }
});

// 去抖状态
let currentAction = null;
let actionCounter = 0;
let lastSent = 0;

// 英文 → 中文显示
function toChinese(a) {
    return a==="LEFT" ? "左" :
           a==="RIGHT"? "右" :
           a==="UP"   ? "上" :
           a==="DOWN" ? "下" :
           "等待动作...";
}

// 串口发送给 micro:bit
async function sendAction(a) {
    if (!writer) return;

    let msg = "0";
    if (a==="LEFT")  msg="L";
    if (a==="RIGHT") msg="R";
    if (a==="UP")    msg="U";
    if (a==="DOWN")  msg="D";

    await writer.write(new TextEncoder().encode(msg+"\n"));
}

// MediaPipe 初始化
let handLandmarker;

async function init() {
    statusEl.textContent = "加载模型...";
    const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
    );

    handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: "./hand_landmarker.task" },
        runningMode: "VIDEO",
        numHands: 1,
    });

    statusEl.textContent = "模型加载完成，启动摄像头...";
    startCamera();
}

function startCamera() {
    navigator.mediaDevices.getUserMedia({ video:true })
        .then(stream=>{
            video.srcObject = stream;
            video.onloadedmetadata = ()=>{
                video.play();
                statusEl.textContent = "摄像头已启动";
                requestAnimationFrame(loop);
            };
        })
        .catch(err=>{
            statusEl.textContent = "无法访问摄像头：" + err;
            console.error(err);
        });
}

async function loop(timestamp) {
    if (!handLandmarker) return;

    canvas.width  = video.videoWidth;
    canvas.height = video.videoHeight;

    const results = await handLandmarker.detectForVideo(video, timestamp);

    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(video,0,0,canvas.width,canvas.height);

    if (results.landmarks && results.landmarks.length > 0) {
       const lm = results.landmarks[0];
const draw = new DrawingUtils(ctx);
draw.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS);
draw.drawLandmarks(lm);

const wrist = lm[0];
const tip   = lm[8];

// 手指方向向量
const vx = tip.x - wrist.x;   // >0 右 <0 左
const vy = tip.y - wrist.y;   // >0 下 <0 上
const len = Math.hypot(vx, vy);

let detected = null;

// -------- 新增：识别“拳头” --------
function dist(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y, a.z - b.z);
}

// 四个手指尖到手腕的距离
const dIndex  = dist(lm[8],  wrist);
const dMiddle = dist(lm[12], wrist);
const dRing   = dist(lm[16], wrist);
const dPinky  = dist(lm[20], wrist);

// 距离阈值，可以之后再微调，值越小要求“拳头”越紧
const fistThreshold = 0.12;

// 当四个指尖都离手腕很近，就认为是拳头
const isFist =
    dIndex  < fistThreshold &&
    dMiddle < fistThreshold &&
    dRing   < fistThreshold &&
    dPinky  < fistThreshold;

// 如果是拳头，就不输出方向（保持等待状态）
if (!isFist && len > dirThreshold) {
    // 只有在不是拳头 & 手指方向足够明显时才判断方向
    if (Math.abs(vx) > Math.abs(vy)) {
        detected = vx > 0 ? "RIGHT" : "LEFT";
    } else {
        detected = vy > 0 ? "DOWN" : "UP";
    }
}
 
 

        if (detected === currentAction) actionCounter++;
        else if (detected) { currentAction = detected; actionCounter = 1; }
        else { currentAction = null; actionCounter = 0; }

        const now = performance.now();

        if (
            currentAction &&
            actionCounter >= framesNeeded &&
            now - lastSent > cooldown
        ) {
            actionEl.textContent = toChinese(currentAction);
            await sendAction(currentAction);
            lastSent = now;
        } else if (!currentAction && now - lastSent > 300) {
            actionEl.textContent = "等待动作...";
        }

    } else {
        actionEl.textContent = "没有检测到手";
        currentAction = null;
        actionCounter = 0;
    }

    requestAnimationFrame(loop);
}

window.addEventListener("load", init);
</script>

</body>
</html>

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>MediaPipe Hands + micro:bit (折中版)</title>
<style>
body { text-align: center; font-family: sans-serif; margin: 10px; }
video, canvas { width: 45%; margin: 5px; border: 1px solid #333; vertical-align: top; }
#status { color: blue; font-size: 18px; }
#action { color: red; font-size: 24px; font-weight: bold; }
</style>
</head>
<body>

<h2>MediaPipe Hands - USB micro:bit (折中版)</h2>
<div id="status">初始化...</div>
<div id="action">等待动作...</div>
<button id="connectBtn">连接 micro:bit</button>
<br>
<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>

<script type="module">
import { HandLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

const statusEl = document.getElementById("status");
const actionEl = document.getElementById("action");
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let handLandmarker;
let lastX = null;
let lastY = null;

// 坐标平滑
let history = [];
const maxHistory = 5;

// 连续帧判定
let actionCounter = 0;
let currentAction = null;

// 冷却时间
let lastSentTime = 0;
const cooldown = 150; // ms

// USB 串口
let port;
let writer;

document.getElementById("connectBtn").addEventListener("click", async () => {
    try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        writer = port.writable.getWriter();
        statusEl.textContent = "micro:bit 已连接";
        connectBtn.disabled = true;
    } catch(e) {
        statusEl.textContent = "连接失败：" + e;
        console.error(e);
    }
});

async function sendAction(action) {
    if (!writer) return;
    let sendMsg = action;
    if (action === "UP") sendMsg = "1";
    else if (action === "DOWN") sendMsg = "2";
    else if (action === "LEFT") sendMsg = "3";
    else if (action === "RIGHT") sendMsg = "4";
    else if (action === "FIST") sendMsg = "5";
    const data = new TextEncoder().encode(sendMsg + "\n");
    await writer.write(data);
}

async function init() {
    statusEl.textContent = "加载模型...";
    const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
    );
    handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: "./hand_landmarker.task" },
        runningMode: "VIDEO",
        numHands: 1,
    });
    statusEl.textContent = "模型加载完成，启动摄像头...";
    startCamera();
}

function startCamera() {
    navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
            video.srcObject = stream;
            video.onloadedmetadata = () => {
                video.play();
                statusEl.textContent = "摄像头启动成功，手势识别中...";
                requestAnimationFrame(loop);
            };
        })
        .catch(err => {
            statusEl.textContent = "无法访问摄像头：" + err;
            console.error(err);
        });
}

async function loop(timestamp) {
    if (!handLandmarker) return;

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    const results = await handLandmarker.detectForVideo(video, timestamp);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    if (results.landmarks && results.landmarks.length > 0) {
        const drawingUtils = new DrawingUtils(ctx);
        for (const landmarks of results.landmarks) {
            drawingUtils.drawConnectors(landmarks, HandLandmarker.HAND_CONNECTIONS);
            drawingUtils.drawLandmarks(landmarks);
        }

        const wrist = results.landmarks[0][0];

        // 平滑坐标
        history.push({x: wrist.x, y: wrist.y});
        if (history.length > maxHistory) history.shift();
        const avgX = history.reduce((sum,h)=>sum+h.x,0)/history.length;
        const avgY = history.reduce((sum,h)=>sum+h.y,0)/history.length;

        // 动作判定
        let detectedAction = "等待动作...";

        const landmarks = results.landmarks[0];
        function dist(a, b) { return Math.hypot(a.x-b.x, a.y-b.y); }
        const thresholdFist = 0.1;
        const dThumb = dist(landmarks[4], wrist);
        const dIndex = dist(landmarks[8], wrist);
        const dMiddle = dist(landmarks[12], wrist);
        const dRing = dist(landmarks[16], wrist);
        const dPinky = dist(landmarks[20], wrist);

        if (dThumb<thresholdFist && dIndex<thresholdFist && dMiddle<thresholdFist && dRing<thresholdFist && dPinky<thresholdFist){
            detectedAction = "FIST";
        } else if (lastX!==null && lastY!==null){
            const dx = avgX - lastX;
            const dy = avgY - lastY;
            const moveThreshold = 0.03; // 更灵敏
            if (Math.abs(dx) > Math.abs(dy)){
                if (dx>moveThreshold) detectedAction="RIGHT";
                else if (dx<-moveThreshold) detectedAction="LEFT";
            } else {
                if (dy>moveThreshold) detectedAction="DOWN";
                else if (dy<-moveThreshold) detectedAction="UP";
            }
        }

        lastX = avgX;
        lastY = avgY;

        // 连续帧判定 + 冷却
        if (detectedAction === currentAction) {
            actionCounter++;
        } else {
            currentAction = detectedAction;
            actionCounter = 1;
        }

        const now = performance.now();
        if (actionCounter >= 2 && detectedAction !== "等待动作..." && (now - lastSentTime > 150)) {
            actionEl.textContent = detectedAction;
            await sendAction(detectedAction);
            lastSentTime = now;
        } else {
            actionEl.textContent = "等待动作...";
        }

    } else {
        actionEl.textContent = "没有检测到手";
    }

    requestAnimationFrame(loop);
}

window.addEventListener("load", init);
</script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>MediaPipe Hands + micro:bit USB</title>
<style>
body { text-align: center; font-family: sans-serif; margin: 10px; }
video, canvas { width: 100%; max-width: 400px; margin: 5px 0; }
#status { color: blue; font-size: 18px; }
#action { color: red; font-size: 24px; font-weight: bold; }
</style>
</head>
<body>

<h2>MediaPipe Hands - USB micro:bit</h2>
<div id="status">初始化...</div>
<div id="action">等待动作...</div>
<button id="connectBtn">连接 micro:bit</button>
<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>

<script type="module">
import { HandLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

const statusEl = document.getElementById("status");
const actionEl = document.getElementById("action");
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let handLandmarker;
let lastX = null;
let lastY = null;

// USB 串口
let port;
let writer;

document.getElementById("connectBtn").addEventListener("click", async () => {
    try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        writer = port.writable.getWriter();
        statusEl.textContent = "micro:bit 已连接";
    } catch(e) {
        statusEl.textContent = "连接失败：" + e;
        console.error(e);
    }
});

async function sendAction(action) {
    if (!writer) return;
    const data = new TextEncoder().encode(action + "\n");
    await writer.write(data);
    console.log("发送:", action);
}

async function init() {
    statusEl.textContent = "加载模型...";
    const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
    );
    handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: "./hand_landmarker.task" },
        runningMode: "VIDEO",
        numHands: 1,
    });
    statusEl.textContent = "模型加载完成，启动摄像头...";
    startCamera();
}

function startCamera() {
    navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
            video.srcObject = stream;
            video.onloadedmetadata = () => {
                video.play();
                statusEl.textContent = "摄像头启动成功，手势识别中...";
                requestAnimationFrame(loop);
            };
        })
        .catch(err => {
            statusEl.textContent = "无法访问摄像头：" + err;
            console.error(err);
        });
}

async function loop(timestamp) {
    if (!handLandmarker) return;

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    const results = await handLandmarker.detectForVideo(video, timestamp);
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    if (results.landmarks && results.landmarks.length > 0) {
        const drawingUtils = new DrawingUtils(ctx);
        for (const landmarks of results.landmarks) {
            drawingUtils.drawConnectors(landmarks, HandLandmarker.HAND_CONNECTIONS);
            drawingUtils.drawLandmarks(landmarks);
        }

        const wrist = results.landmarks[0][0];
        let action = "等待动作...";

        if (lastX !== null && lastY !== null) {
            const dx = wrist.x - lastX;
            const dy = wrist.y - lastY;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0.02) action = "RIGHT";
                else if (dx < -0.02) action = "LEFT";
            } else {
                if (dy > 0.02) action = "DOWN";
                else if (dy < -0.02) action = "UP";
            }
        }

        lastX = wrist.x;
        lastY = wrist.y;
        actionEl.textContent = action;

        await sendAction(action);
    } else {
        actionEl.textContent = "没有检测到手";
    }

    requestAnimationFrame(loop);
}

window.addEventListener("load", init);
</script>
</body>
</html>

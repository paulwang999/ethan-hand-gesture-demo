<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Hand Gesture + micro:bit BLE</title>
  <style>
    video, canvas {
      width: 100%;
      max-width: 400px;
    }
    #connectBtn {
      padding: 10px 20px;
      font-size: 18px;
      margin: 10px 0;
      background: #4CAF50;
      color: white;
      border-radius: 8px;
      border: none;
    }
  </style>
</head>

<body>
  <h2>Hand Gesture to micro:bit</h2>

  <button id="connectBtn">ğŸ”µ è¿æ¥åˆ° micro:bit</button>

  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>

  <script type="module">
    import {
      HandLandmarker,
      FilesetResolver,
      DrawingUtils
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    // ----------------------
    // ğŸ”µ BLE ç›¸å…³å˜é‡
    // ----------------------
    let microbitDevice = null;
    let ledService = null;    // ç”¨ micro:bit çš„ LED Service å†™æ•°æ®

    document.getElementById("connectBtn").onclick = async () => {
      try {
        microbitDevice = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: "BBC micro:bit" }],
          optionalServices: ["e95dd91d-251d-470a-a062-fa1922dfa9a8"] // LED service
        });

        const server = await microbitDevice.gatt.connect();

        ledService = await server.getPrimaryService(
          "e95dd91d-251d-470a-a062-fa1922dfa9a8"
        );

        alert("æˆåŠŸè¿æ¥ micro:bit âœ”");
      } 
      catch (err) {
        console.error(err);
        alert("è¿æ¥å¤±è´¥ï¼Œè¯·é‡è¯•");
      }
    };

    // å†™å…¥æ–‡æœ¬åˆ° micro:bitï¼ˆ0=ç­ç¯ï¼Œ1=äº®ç¯ï¼‰
    async function sendGestureToMicrobit(command) {
      if (!ledService) return;

      try {
        const char = await ledService.getCharacteristic(
          "e95d7b77-251d-470a-a062-fa1922dfa9a8"
        );

        const data = new TextEncoder().encode(command);
        await char.writeValue(data);
        console.log("Sent to micro:bit:", command);

      } catch (err) {
        console.error("Write error:", err);
      }
    }

    // ----------------------
    // ğŸ¤– MediaPipe åˆå§‹åŒ–
    // ----------------------
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    let handLandmarker;

    async function init() {
      const vision = await FilesetResolver.forVisionTasks(
        "./wasm"  // ä½ çš„æ¨¡å‹æ–‡ä»¶å¤¹
      );

      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "./wasm/hand_landmarker.task"
        },
        runningMode: "VIDEO",
        numHands: 1
      });

      startCamera();
    }

    function startCamera() {
      navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          video.play();
          requestAnimationFrame(loop);
        };
      });
    }

    async function loop(timestamp) {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;

      const results = await handLandmarker.detectForVideo(video, timestamp);

      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      if (results.landmarks) {
        const drawingUtils = new DrawingUtils(ctx);

        for (const lm of results.landmarks) {
          drawingUtils.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS);
          drawingUtils.drawLandmarks(lm);
        }

        const p0 = results.landmarks[0][0]; // æ‰‹è…•ç‚¹

        // ç®€å•åˆ¤æ–­ç¤ºä¾‹ï¼ˆä½ å¯æ›´ç²¾ç¡®ï¼‰
        if (p0.x < 0.3) sendGestureToMicrobit("LEFT");
        if (p0.x > 0.7) sendGestureToMicrobit("RIGHT");
        if (p0.y < 0.3) sendGestureToMicrobit("UP");
        if (p0.y > 0.7) sendGestureToMicrobit("DOWN");
      }

      requestAnimationFrame(loop);
    }

    init();
  </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Hand Gesture + micro:bit BLE</title>
  <style>
    .video-container {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    video, canvas {
      width: 48%;
      max-width: 400px;
      border: 2px solid #333;
      border-radius: 8px;
    }
    #connectBtn {
      padding: 10px 20px;
      font-size: 18px;
      margin: 10px 0;
      background: #4CAF50;
      color: white;
      border-radius: 8px;
      border: none;
    }
  </style>
</head>

<body>
  <h2>Hand Gesture + micro:bit BLE</h2>
  <button id="connectBtn">üîµ ËøûÊé•Âà∞ micro:bit</button>

  <div class="video-container">
    <video id="video" autoplay playsinline></video>
    <canvas id="canvas"></canvas>
  </div>

  <script type="module">
    import {
      HandLandmarker,
      FilesetResolver,
      DrawingUtils
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    // ----------------------
    // BLE ÂèòÈáè
    // ----------------------
    let microbitDevice = null;
    let ledService = null;

    document.getElementById("connectBtn").onclick = async () => {
      try {
        microbitDevice = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: "BBC micro:bit" }],
          optionalServices: ["e95dd91d-251d-470a-a062-fa1922dfa9a8"]
        });

        const server = await microbitDevice.gatt.connect();
        ledService = await server.getPrimaryService(
          "e95dd91d-251d-470a-a062-fa1922dfa9a8"
        );

        alert("ÊàêÂäüËøûÊé• micro:bit ‚úî");
      } catch (err) {
        console.error(err);
        alert("ËøûÊé•Â§±Ë¥•ÔºåËØ∑ÈáçËØï");
      }
    };

    async function sendGestureToMicrobit(command) {
      if (!ledService) return;
      try {
        const char = await ledService.getCharacteristic(
          "e95d7b77-251d-470a-a062-fa1922dfa9a8"
        );
        const data = new TextEncoder().encode(command);
        await char.writeValue(data);
        console.log("Sent:", command);
      } catch (err) {
        console.error("Write error:", err);
      }
    }

    // ----------------------
    // MediaPipe ÊâãÂäøËØÜÂà´
    // ----------------------
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let handLandmarker;

    async function init() {
      const vision = await FilesetResolver.forVisionTasks("./wasm");
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: "./wasm/hand_landmarker.task" },
        runningMode: "VIDEO",
        numHands: 1
      });

      startCamera();
    }

    function startCamera() {
      navigator.mediaDevices.getUserMedia({ video: true })
        .then((stream) => {
          video.srcObject = stream;
          video.onloadedmetadata = () => {
            video.play();
            requestAnimationFrame(loop);
          };
        })
        .catch(err => console.error("ÊëÑÂÉèÂ§¥Â§±Ë¥•:", err));
    }

    async function loop(timestamp) {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;

      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      const results = await handLandmarker.detectForVideo(video, timestamp);

      if (results.landmarks) {
        const drawingUtils = new DrawingUtils(ctx);
        for (const lm of results.landmarks) {
          drawingUtils.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS);
          drawingUtils.drawLandmarks(lm);
        }

        const p0 = results.landmarks[0][0];

        if (p0.x < 0.3) sendGestureToMicrobit("LEFT");
        else if (p0.x > 0.7) sendGestureToMicrobit("RIGHT");
        else if (p0.y < 0.3) sendGestureToMicrobit("UP");
        else if (p0.y > 0.7) sendGestureToMicrobit("DOWN");
      }

      requestAnimationFrame(loop);
    }

    init();
  </script>
</body>
</html>
